# MCP 구조 및 루트 경로 제한에 대한 피드백 보고서: OpenManager Vibe V4

`openmanager-vibe-v4` 프로젝트의 `mcp-lite-server` 구조, 특히 컨텍스트 파일 접근 방식 및 사용자가 언급한 루트 경로 제한과 관련된 피드백을 기술합니다. 또한 `/query` 엔드포인트 기능 개선 방안을 제안합니다.

## 1. 현재 MCP 컨텍스트 파일 접근 방식 분석

`mcp-lite-server/server.js`의 `/query` 엔드포인트는 클라이언트로부터 `context` (파일명) 파라미터를 전달받아 서버 내의 특정 파일을 읽는 방식으로 동작합니다.

*   **동작 메커니즘:**
    *   클라이언트는 API 요청 시 JSON 본문에 `{"query": "사용자 질문", "context": "원하는_컨텍스트_파일명"}` 형식으로 데이터를 전송합니다.
    *   서버는 이 `context` 값을 받아, 자신의 코드 내에 하드코딩된 기본 경로인 `./context/` 디렉토리와 조합하여 실제 파일 경로를 생성합니다. 예를 들어, 클라이언트가 `context`로 "server-status"를 보내면, 서버는 `./context/server-status.txt` 파일을 대상으로 작업을 수행합니다.
*   **보안 분석:**
    *   이 방식은 **경로 순회(Path Traversal) 공격으로부터 안전한 설계**로 볼 수 있습니다. 클라이언트는 파일명만 지정할 수 있을 뿐, `../` 와 같은 상위 디렉토리 이동 문자를 포함시키거나 절대 경로를 지정하여 서버의 임의의 파일 시스템 위치에 접근할 수 없습니다.
    *   서버가 컨텍스트 파일이 위치할 기본 디렉토리(`./context/`)를 완전히 제어하고, 클라이언트 입력값은 파일명으로만 제한적으로 사용되기 때문에, 서버가 의도하지 않은 파일에 접근하는 것을 효과적으로 방지합니다.

## 2. 사용자 언급 로컬 경로 (`D:/cursor`) 관련 피드백

사용자께서 특정 로컬 파일 시스템 경로(예: `D:/cursor/...`)에 대한 접근 제한을 언급하신 부분에 대해 다음과 같이 피드백 드립니다.

*   **현재 코드베이스 상태:** GitHub 저장소에 있는 `openmanager-vibe-v4` 프로젝트의 `mcp-lite-server` 코드에는 사용자 개인 PC의 특정 절대 경로(예: `D:/cursor`)를 참조하거나 의존하는 부분이 **포함되어 있지 않습니다.**
*   **추정되는 상황:** 해당 경로는 사용자 개인의 로컬 개발 환경에서 MCP 서버를 테스트하거나 컨텍스트 파일을 관리할 때 사용된 개인적인 설정으로 보입니다. 이는 일반적인 개발 과정에서 로컬 테스트를 위해 특정 경로를 사용할 수 있는 흔한 경우입니다.
*   **배포 관점에서의 영향:** 현재 공유되거나 배포될 가능성이 있는 코드 자체는 위 1번 항목에서 설명한 대로 `./context/` 라는 상대 경로를 사용하고 있습니다. 따라서, 실제 서버가 배포되어 운영될 때는 특정 사용자의 로컬 PC 절대 경로에 대한 의존성이나 접근 제한을 걱정할 필요가 없습니다. 서버는 자신이 배포된 위치를 기준으로 상대 경로를 해석하여 파일을 찾게 됩니다.

## 3. MCP 서버 `/query` 엔드포인트 기능 개선 제안

현재 `/query` 엔드포인트는 사용자의 `query` 문자열에 포함된 단어 중 하나라도 컨텍스트 파일의 특정 줄에 존재하면 해당 줄 전체를 반환하는 단순한 매칭 로직을 사용하고 있습니다. 이는 초기 구현으로는 유용할 수 있으나, 다음과 같은 개선을 통해 기능을 향상할 수 있습니다.

*   **향상된 키워드 매칭 로직:**
    *   **단순 포함에서 벗어나기:** 현재는 `query.split(' ').some(word => line.includes(word))` 로직을 사용하는데, 이는 한 단어만 일치해도 해당 줄을 반환합니다. 이로 인해 관련성이 낮은 결과가 반환될 수 있습니다.
    *   **제안:**
        *   **다중 키워드 우선순위 부여:** 질문에서 추출된 여러 핵심 키워드가 한 줄에 같이 등장하는 경우 더 높은 점수를 부여하여 우선적으로 반환하도록 개선할 수 있습니다. (예: "CPU"와 "높음"이 함께 있는 줄)
        *   **TF-IDF 또는 유사도 기반 매칭:** 간단한 TF-IDF(Term Frequency-Inverse Document Frequency) 계산을 통해 질문과 각 줄 간의 관련성을 평가하거나, 문자열 유사도 알고리즘(예: Jaccard 유사도, Levenshtein 거리)을 활용하여 가장 유사한 줄을 찾는 방식을 도입할 수 있습니다.

*   **간단한 정규표현식(Regex) 활용:**
    *   **목적:** 컨텍스트 파일 내에서 특정 패턴의 정보를 추출하거나, 보다 유연한 질문에 대응하기 위함입니다.
    *   **예시:** 컨텍스트 파일에 `CPU 사용률: [수치]%` 와 같은 패턴이 있고, 사용자가 "CPU 사용률 몇 퍼센트야?" 라고 질문했을 때, 정규표현식을 사용하여 해당 수치를 정확히 추출하여 답변할 수 있습니다.
    *   **구현:** 컨텍스트 파일의 각 줄 또는 특정 키워드에 대해 미리 정의된 정규표현식 패턴과 매칭시켜, 그룹화된 정보를 추출하여 응답에 활용합니다.

*   **`ai_agent.js` 로직 일부 연동:**
    *   **현황:** 현재 `/api/ai/query` 엔드포인트는 `ai_agent.js`를 통해 Z-score 기반의 통계적 이상 감지 등 좀 더 지능적인 분석을 수행합니다.
    *   **제안:** `/query` 엔드포인트에서도 단순 텍스트 매칭뿐만 아니라, `ai_agent.js`의 특정 분석 함수를 호출하여 컨텍스트 파일 내용과 함께 간단한 실시간 데이터 기반 분석 결과를 조합하여 제공하는 것을 고려할 수 있습니다. 예를 들어, "서버 상태 어때?" 라는 질문에 대해 `server-status.txt` 파일의 일반적인 상태 정보와 함께, `ai_agent.js`가 실시간 메트릭을 분석하여 "web-01 서버의 CPU 사용량이 평소보다 높습니다." 와 같은 동적인 정보를 추가할 수 있습니다.

*   **구조화된 컨텍스트 파일 형식 도입 (장기적 관점):**
    *   **현황:** 현재는 단순 `.txt` 파일을 줄 단위로 파싱합니다.
    *   **제안:** 장기적으로는 각 컨텍스트 파일의 내용을 좀 더 구조화된 형식(예: JSON, YAML)으로 변경하는 것을 고려할 수 있습니다.
        ```yaml
        # 예시: server-issues.yaml
        - keywords: ["cpu", "높음", "과부하"]
          question_pattern: "CPU 사용률이 높은 서버는?"
          response_template: "CPU 사용률이 높은 서버는 {{servers}} 입니다. 주요 원인은 {{causes}}일 수 있습니다."
          related_metrics: ["cpu_usage"]
        - keywords: ["메모리", "부족"]
          # ...
        ```
    *   **이점:** 이를 통해 질문의 의도(intent), 필수 키워드, 응답 생성 템플릿, 관련 데이터 소스 등을 명확히 정의할 수 있어, 보다 정교하고 다양한 형태의 응답 생성이 가능해지며 컨텍스트 관리도 용이해집니다.

이러한 개선 방안들은 `/query` 엔드포인트가 사용자 질문에 대해 더욱 정확하고 유용한 정보를 제공하는 데 기여할 수 있을 것입니다.
